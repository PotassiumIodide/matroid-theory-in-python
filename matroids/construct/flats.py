from itertools import combinations_with_replacement
from typing    import Callable, TypeVar

from matroids.core.set_operator import powset

import matroids.construct.closure_function as closure_function

T = TypeVar('T')


def from_independent_matroid(matroid: tuple[set[T], list[set[T]]]) -> list[set[T]]:
    """Construct flats from a matroid defined by independent sets.

    Args:
        matroid (tuple[set[T], list[set[T]]]): A matroid defined by independent sets.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, _ = matroid
    return from_closure_matroid((E, closure_function.from_independent_matroid(matroid)))


def from_dependent_matroid(matroid: tuple[set[T], list[set[T]]]) -> list[set[T]]:
    """Construct flats from a matroid defined by dependent sets.

    Args:
        matroid (tuple[set[T], list[set[T]]]): A matroid defined by dependent sets.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, _ = matroid
    return from_closure_matroid((E, closure_function.from_dependent_matroid(matroid)))



def from_bases_matroid(matroid: tuple[set[T], list[set[T]]]) -> list[set[T]]:
    """Construct flats from a matroid defined by bases.

    Args:
        matroid (tuple[set[T], list[set[T]]]): A matroid defined by bases.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, _ = matroid
    return from_closure_matroid((E, closure_function.from_bases_matroid(matroid)))


def from_circuits_matroid(matroid: tuple[set[T], list[set[T]]]) -> list[set[T]]:
    """Construct flats from a matroid defined by circuits.

    Args:
        matroid (tuple[set[T], list[set[T]]]): A matroid defined by circuits.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, _ = matroid
    return from_closure_matroid((E, closure_function.from_circuits_matroid(matroid)))


def from_rank_matroid(matroid: tuple[set[T], Callable[[set[T]], int]]) -> list[set[T]]:
    """Construct flats from a matroid defined by a rank function.

    Args:
        matroid (tuple[set[T], Callable[[set[T]], int]]): A matroid defined by a rank function.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, r = matroid
    # Fs = { F ⊆ E : r(F ∪ {e}) = r(F) + 1, ∀e ∈ E\F }
    return [ F for F in powset(E) if all(map(lambda e: r(F | {e}) == r(F) + 1, E - F))]


def from_nulity_matroid(matroid: tuple[set[T], Callable[[set[T]], int]]) -> list[set[T]]:
    """Construct flats from a matroid defined by a nulity function.

    Args:
        matroid (tuple[set[T], Callable[[set[T]], int]]): A matroid defined by a nulity function.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, n = matroid
    # Fs = { F ⊆ E : n(F ∪ {e}) - n(F) = |F ∪ {e}| - |F| + 1, ∀e ∈ E\F }
    return [ F for F in powset(E) if all(map(lambda e: n(F | {e}) - n(F) == len(F | {e}) - len(F) - 1, E - F))]


def from_closure_matroid(matroid: tuple[set[T], Callable[[set[T]], set[T]]]) -> list[set[T]]:
    """Construct flats from a matroid defined by a closure function.

    Args:
        matroid (tuple[set[T], Callable[[set[T]], set[T]]]): A matroid defined by a closure function.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, cl = matroid
    # Fs = { F ⊆ E | cl(F) = F }
    return [F for F in powset(E) if cl(F) == F]


def from_open_matroid(matroid: tuple[set[T], list[set[T]]]) -> list[set[T]]:
    """Construct flats from a matroid defined by open sets.

    Args:
        matroid (tuple[set[T], list[set[T]]]): A matroid defined by open sets.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, Os = matroid
    # Fs = { E - O : O ∈ Os }
    return [ E - O for O in Os ]


def from_hyperplanes_matroid(matroid: tuple[set[T], list[set[T]]]) -> list[set[T]]:
    """COnstruct flats from a matroid defined by hyperplanes.

    Args:
        matroid (tuple[set[T], list[set[T]]]): A matroid defined by hyperplanes.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, Hs = matroid
    # Fs is a group generated by Hs under the intersection.
    Hs.append(E)
    all_intersection = lambda Xs: [X for X in powset(E) if X in [A & B for A, B in combinations_with_replacement(Xs, 2)]]
    
    tmp = all_intersection(Hs)
    # Repeat unless the set is closed under the intersection.
    # This loop must be stopped because E is finite, and E includes any intersection.
    while True:
        next_tmp = all_intersection(tmp)
        if len(tmp) == len(next_tmp):
            return tmp
        tmp = next_tmp


def from_spanning_matroid(matroid: tuple[set[T], list[set[T]]]) -> list[set[T]]:
    """Construct flats from a matroid defined by spanning sets.

    Args:
        matroid (tuple[set[T], list[set[T]]]): A matroid defined by spanning sets.

    Returns:
        list[set[T]]: The flats of a given matroid.
    """
    E, _ = matroid
    return from_closure_matroid((E, closure_function.from_spanning_matroid(matroid)))